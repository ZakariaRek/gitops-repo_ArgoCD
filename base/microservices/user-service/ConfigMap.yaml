apiVersion: v1
kind: ConfigMap
metadata:
  name: user-service-config
  namespace: microservices
  labels:
    app: user-service
    component: microservices
data:
  application.yml: |
    server:
      port: 8081
      servlet:
        context-path: /api/users
      error:
        include-stacktrace: always
        include-message: always
        include-binding-errors: always
      # Add connection timeouts
      connection-timeout: 60000
      tomcat:
        threads:
          max: 50
          min-spare: 5
        max-connections: 200
        accept-count: 50
    
    debug: false  # Disable debug mode for better performance
    
    spring:
      profiles:
        active: docker,kafka
      config:
        import: optional:configserver:${SPRING_CLOUD_CONFIG_URI:http://config-server.infrastructure.svc.cluster.local:8888}
      application:
        name: user-service
      
      # MongoDB Configuration - Fixed to use Kubernetes service
      data:
        mongodb:
          host: ${SPRING_DATA_MONGODB_HOST:user-mongodb-headless.data.svc.cluster.local}
          port: ${SPRING_DATA_MONGODB_PORT:27017}
          database: ${SPRING_DATA_MONGODB_DATABASE:User-service}
          username: ${SPRING_DATA_MONGODB_USERNAME:userservice}
          password: ${SPRING_DATA_MONGODB_PASSWORD:userservice123}
          uri: ${SPRING_DATA_MONGODB_URI:mongodb://userservice:userservice123@user-mongodb-headless.data.svc.cluster.local:27017/User-service?authSource=admin&connectTimeoutMS=30000&socketTimeoutMS=30000&serverSelectionTimeoutMS=30000}
      
      # Zipkin Configuration - Disabled for now
      zipkin:
        enabled: false
        base-url: ${SPRING_ZIPKIN_BASE_URL:http://zipkin-server.infrastructure:9411}
      sleuth:
        zipkin:
          base-url: ${SPRING_SLEUTH_ZIPKIN_BASE_URL:http://zipkin-server.infrastructure:9411}
        sampler:
          probability: 0.0  # Disabled
      
      # OPTIMIZED Kafka Configuration - Reduced resource consumption
      kafka:
        bootstrap-servers: ${SPRING_KAFKA_BOOTSTRAP_SERVERS:kafka-service.data.svc.cluster.local:9092}
        # Connection and timeout settings
        client-id: user-service-${random.uuid}
        properties:
          # Connection settings to prevent resource exhaustion
          connections.max.idle.ms: 300000  # 5 minutes
          request.timeout.ms: 30000        # 30 seconds
          session.timeout.ms: 30000        # 30 seconds
          heartbeat.interval.ms: 10000     # 10 seconds
          metadata.max.age.ms: 300000      # 5 minutes
          # Reduce network traffic
          fetch.min.bytes: 1024
          fetch.max.wait.ms: 5000
        producer:
          key-serializer: org.apache.kafka.common.serialization.StringSerializer
          value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
          # Producer optimizations
          batch-size: 16384
          linger-ms: 5
          buffer-memory: 33554432
          # Reduce retries and timeout for faster failure
          retries: 2
          request-timeout-ms: 30000
          delivery-timeout-ms: 120000
          properties:
            spring.json.add.type.headers: false
            acks: 1  # Reduced from 'all' for better performance
            enable.idempotence: false  # Disabled for better performance
            compression.type: snappy
        consumer:
          group-id: ${SPRING_KAFKA_CONSUMER_GROUP_ID:user-service-group}
          auto-offset-reset: earliest
          enable-auto-commit: true  # CHANGED: Enable auto-commit to reduce load
          auto-commit-interval: 5000
          # Consumer optimizations
          max-poll-records: 10  # Reduced batch size
          max-poll-interval-ms: 300000  # 5 minutes
          session-timeout-ms: 30000     # 30 seconds
          heartbeat-interval-ms: 10000   # 10 seconds
          fetch-min-size: 1024
          fetch-max-wait: 5000
          key-deserializer: org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
          value-deserializer: org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
          properties:
            spring.deserializer.key.delegate.class: org.apache.kafka.common.serialization.StringDeserializer
            spring.deserializer.value.delegate.class: org.springframework.kafka.support.serializer.JsonDeserializer
            spring.json.trusted.packages: "*"
            spring.json.use.type.headers: false
            spring.json.value.default.type: java.lang.Object
        # Listener configuration
        listener:
          concurrency: 1  # Single thread to reduce resource usage
          poll-timeout: 3000
          type: single
          ack-mode: batch
    
    # OPTIMIZED Eureka Configuration - Reduced frequency and added timeouts
    eureka:
      instance:
        preferIpAddress: true
        instanceId: ${spring.application.name}:${server.port}
        hostname: user-service
        # Increased lease renewal and expiration intervals
        lease-renewal-interval-in-seconds: 30     # Increased from 5
        lease-expiration-duration-in-seconds: 90  # Increased from default
        metadataMap:
          instanceId: ${spring.application.name}:${server.port}
      client:
        # REDUCED frequency to prevent overwhelming Eureka server
        registryFetchIntervalSeconds: 30          # Increased from 5
        instanceInfoReplicationIntervalSeconds: 30 # Increased from 5
        initialInstanceInfoReplicationIntervalSeconds: 40 # Increased from 5
        eurekaServiceUrlPollIntervalSeconds: 300   # Increased from 5
        # Connection and timeout settings
        eureka-server-connect-timeout-seconds: 30
        eureka-server-read-timeout-seconds: 30
        eureka-connection-idle-timeout-seconds: 30
        registerWithEureka: true
        fetchRegistry: true
        # Registry processing optimizations
        disable-delta: false
        cache-refresh-executor-thread-pool-size: 2
        cache-refresh-executor-exponential-back-off-bound: 10
        serviceUrl:
          defaultZone: ${EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE:http://eureka-server.infrastructure.svc.cluster.local:8761/eureka}
    
    # Management and Monitoring - Optimized
    management:
      health:
        mongo:
          enabled: true
        eureka:
          enabled: true
        kafka:
          enabled: true
      endpoint:
        health:
          show-details: "WHEN_AUTHORIZED"  # Reduced verbosity
          show-components: "WHEN_AUTHORIZED"
        metrics:
          enabled: true
      endpoints:
        web:
          exposure:
            include: "health,info,metrics,prometheus"  # Reduced endpoints
          cors:
            allowed-origins: "*"
            allowed-methods: "GET,POST,PUT,DELETE,OPTIONS"
      metrics:
        distribution:
          percentiles-histogram:
            http.server.requests: true
          percentiles:
            http.server.requests: 0.5, 0.95, 0.99
        tags:
          application: ${spring.application.name}
      tracing:
        sampling:
          probability: 0.0  # Disabled for now
    
    # JWT Configuration
    User-service:
      app:
        jwtCookieName: ${USER_SERVICE_APP_JWT_COOKIE_NAME:user-service}
        jwtSecret: ${USER_SERVICE_APP_JWT_SECRET:c03a546beee68b92784e681b537540349c386d02b6dbf9917cf438e47e5c1ee93fdebc55652af00cb3ebc6bff17dc3bedaa33ea6cfdd1959b114ede448c4ac87853021cc3c32f1ef6d5951d0c6b1398bc01c563c7638a0000e6b4064c5733c5552aa232aa8547be8b4b1f8dddacac8256f319acd6832ff5ae9365358e20624fc99dab8489d33e582cf621444e9d944442559707a1f92d556862bb53ce12deb3ec17d3a8bc3c7159b672e4f02189af368a8e71d8547a5b71518de7a1d9a4997d20b4f646fae73e73c26666799b21cdec5544b74319756bb0a27d4e124ec5f13bf8f338ce3ba5ad8b3af1a8aae211bef3eb6ca4f8a24e6b80662c94530e168b0dc}
        jwtExpirationMs: ${USER_SERVICE_APP_JWT_EXPIRATION_MS:86400000}
    
    # OAuth2 Application Configuration
    app:
      oauth2:
        authorizedRedirectUris: "${APP_OAUTH2_AUTHORIZED_REDIRECT_URIS:http://localhost:3000/auth/oauth2/redirect}"
    
    # User Service Specific Configuration
    user:
      session:
        timeout: 1800 # 30 minutes
      cleanup:
        schedule: "0 0 */6 * * *" # Every 6 hours
    
    # OPTIMIZED Logging Configuration 
    logging:
      level:
        root: INFO
        com.Ecommerce.User_Service: INFO  # Reduced from DEBUG
        org.springframework.kafka: WARN   # Reduced noise
        org.apache.kafka: ERROR          # Reduced noise
        org.springframework.cloud.netflix.eureka: WARN  # Reduced noise
        org.springframework.security: WARN
        org.springframework.web: WARN
        org.springframework.boot.actuate: WARN
        # Reduce Eureka noise
        com.netflix.discovery: WARN
        com.netflix.eureka: WARN
      pattern:
        console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [${spring.application.name}] %logger{40} - %msg%n"
      file:
        name: /dev/stdout
      logback:
        rollingpolicy:
          max-file-size: 0MB  # Disable file logging
    
    # Task Executor Configuration
    task:
      execution:
        pool:
          core-size: 5
          max-size: 10
          queue-capacity: 25
      scheduling:
        pool:
          size: 2